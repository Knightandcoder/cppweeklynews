---
layout: post
title:  第四期
---



从[reddit](https://www.reddit.com/r/cpp/)/[hackernews](https://news.ycombinator.com/)/[lobsters](https://lobste.rs/)/[meetingcpp](https://www.meetingcpp.com/blog/blogroll/)摘抄一些c++动态。

每周更新

周刊项目地址 [github](https://github.com/wanghenshui/cppweeklynews)，[在线地址](https://wanghenshui.github.io/cppweeklynews/) | [discord讨论群组](https://discord.gg/cZ9mXVPGx6) ｜[知乎专栏](https://www.zhihu.com/column/c_1347597234435944448)

欢迎投稿，推荐或自荐文章/软件/资源等，请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)

---

## 资讯

### 编译器信息最新动态推荐关注hellogcc公众号

[本周周报github直达](https://github.com/hellogcc/osdt-weekly/blob/master/weekly/2021-03-17.md)



## 文章

- [Non-Terminal Variadic Parameters and Default Values](https://www.cppstories.com/2021/non-terminal-variadic-args/)

c++20不允许这样的代码

```c++
template <typename ...Args>
void log(Args&& ...args, source_location& loc = source_location::current()) { }

log("hello world", 42);
```

本文讲了几个解决办法

1 手写变参

```c++
template <typename T>
void log(T&& arg, source_location& loc = current());
template <typename T, typename U>
void log(T&& t, U&& u, source_location& loc = current());
template <typename T, typename U, typename V>
void log(T&& t, U&& u, V&& v, source_location& loc = current());
```

非常98

2 显式

```c++
#include <iostream>
#include <source_location>
#include <string>

template <typename... Ts>
void log(Ts&&... ts, const std::source_location& loc = std::source_location::current()) {
    std::cout << loc.function_name() << " line " << loc.line() << ": ";
        ((std::cout << std::forward<Ts>(ts) << " "), ...);
        std::cout << '\n';
}

int main() {
    log<int, int, std::string>(42, 100, "hello world");
    log<double, std::string>(10.75, "an important parameter");
}
```

笨

3 通过构造函数打印，写辅助推导

```c++
#include <iostream>
#include <source_location>
#include <string>

template <typename... Ts>
struct log
{    
    log(Ts&&... ts, const std::source_location& loc = std::source_location::current()) {
        std::cout << loc.function_name() << " line " << loc.line() << ": ";
        ((std::cout << std::forward<Ts>(ts) << " "), ...);
        std::cout << '\n';
    }
};

template <typename... Ts>
log(Ts&&...) -> log<Ts...>;

int main() {
    log(42, 100, "hello world");
    log(10.75, "an important parameter");
}
```

通过构造函数打印，也不是不行，就是很别扭

4 更进一步

```c++
#include <iostream>
#include <string_view>
#include <source_location>
#include <fmt/core.h>

struct Logger {
    Logger(std::source_location l = std::source_location::current()) : loc(std::move(l)) { }
    
    template <typename ...Args>
    void debug(std::string_view format, Args&& ...args) {
	    std::cout << fmt::format("{}({}) ", loc.file_name(), loc.line())
                  << fmt::format(format, std::forward<Args>(args)...) << '\n';
    }
    
private:
    std::source_location loc;    
};
 
int main() {
    std::cout << sizeof(std::source_location) << '\n';
    Logger().debug("{}, {}", "hello", "world");
    Logger().debug("{}, {}", 10, 42);
}
```

5 用tuple

```c++
#include <iostream>
#include <source_location>
#include <string>
#include <tuple>

template <typename... Ts>
void log(std::tuple<Ts...> tup, const std::source_location& loc = std::source_location::current()) {
    std::cout << loc.function_name() << " line " << loc.line() << ": ";
    std::apply([](auto&&... args) {
        ((std::cout << args << ' '), ...);
    }, tup);
    std::cout << '\n';
}

int main() {
    log(std::make_tuple(42, 100, "hello world"));
    log(std::make_tuple(10.75, "an important parameter"));
}
```

6 用stream

7 这里还有点点子 https://cor3ntin.github.io/posts/variadic/



- [Executing a Future in a Separate Thread with Coroutines](https://www.modernescpp.com/index.php/executing-a-future-in-a-separate-thread-with-coroutines)

还是讨论future和coroutines





- [c++ tip of week 217  **Did you know the difference between fakes, stubs, mocks** ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/217.md)

看代码

```c++
class api {
 public:
  virtual ~api() = default;
  virtual auto call() const -> int { return {}; }
};

struct fake_api final : api {
  auto call() const -> int override { return 42; }
};

struct stub_api final : api {
  int call_value{};
  auto call() const -> int override { ++call_calls; return call_value; }
  mutable int call_calls{};
};

int main() {
  {
    fake_api api{};
    assert(42 == api.call());
  }

  {
    stub_api api{};
    assert(0 == api.call_calls);
    api.call_value = 43;
    assert(43 == api.call());
    assert(1 == api.call_calls);
  }

  {
    fakeit::Mock<api> api{};
    fakeit::When(Method(api, call)).Return(43);
    auto &mock_api = api.get();
    assert(43 == mock_api.call());
  }
}
```



- [How C++ Resolves a Function Call](https://preshing.com/20210315/how-cpp-resolves-a-function-call/)

讲的非常细节，把编译器处理的整个流程顺了一遍

-  [Does `throw x` implicit-move? Let’s ask SFINAE](https://quuxplusone.github.io/blog/2021/03/18/sfinae-on-throw-x/)

简单说就是这么一段代码，throw v v本身是不是move的

```c++
std::unique_ptr<int> a(std::unique_ptr<int> p)
{
    auto v = std::make_unique<int>(1);
    return v;  // OK: implicit move (since C++11ish)
    return p;  // OK: implicit move (since C++11ish)
}

void b(std::unique_ptr<int> p)
{
    auto v = std::make_unique<int>(1);
    throw v;  // OK: implicit move (since C++14ish)
    throw p;  // OK: implicit move (since C++20)
}
```

那么这段代码匹配那个函数呢

```c++
template<class T>
auto f(T p, int) -> decltype(throw p)
{
    puts("one");  // #1
    throw p;
}

template<class T>
auto f(T p, long) -> void
{
    puts("two");  // #2
    throw p;
}

int main() {
    f(std::make_unique<int>(42), 42);
}
```

可以[Godbolt](https://godbolt.org/z/1197dM)自己调一下看看



- [Counting the number of fields in an aggregate in C++20](https://joaobapt.medium.com/counting-the-number-of-fields-in-an-aggregate-in-c-20-c81aecfd725c)

读着读着发现就是magic_get/boost.pfr的方法，利用结构化绑定探测字段



## 视频

- [C++ Weekly - Ep 263 - Virtual Inheritance: Probably Not What You Think It Is](https://www.youtube.com/watch?v=vZPkYvsqQxQ&t=31s)

没啥新鲜的，讲继承的



---

看到这里或许你有建议或者疑问或者指出错误，请留言评论! 多谢!  你的评论非常重要！

