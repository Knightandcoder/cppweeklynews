---
layout: post
title:  第一期
---



每周日推送从[reddit](https://www.reddit.com/r/cpp/)/[hackernews](https://news.ycombinator.com/)/[lobsters](https://lobste.rs/)/[meetingcpp](https://www.meetingcpp.com/blog/blogroll/)摘抄一些c++动态。

周刊项目地址 [github](https://github.com/wanghenshui/cppweeklynews)，[在线地址](https://wanghenshui.github.io/cppweeklynews/) | [discord讨论群组](https://discord.gg/cZ9mXVPGx6)

欢迎投稿，推荐或自荐文章/软件/资源等，请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)

---

## 资讯

**herb发了[trip report](https://herbsutter.com/2021/02/22/trip-report-winter-2021-iso-c-standards-meeting-virtual/)**

关于c++标准会的最新进展 c++23

herb介绍了几个他感兴趣的小补丁

- lambda可以省略括号()，但是如果有mutable又不可以省略括号了，需要修订
- range使用：std::views::join迭代器返回有问题，引入新组件修复
- 加强std::visit处理继承std::variant 的场景

- 引入std::to_underlying代替 `std::underlying_type_t<T>`

涉及到语法细节我也不懂，可以看trip report中引用的论文看详细细节



[**c++20 运行时拿到函数名，使用lambda和std::source_location**](https://www.reddit.com/r/cpp/comments/lp40ag/c20_gcc_trunk_getting_constexpr_usable_caller/)

感觉能用在反射上

之前c++ weekly也讨论了std::source_location  [链接](https://www.youtube.com/watch?v=TAS85xmNDEc) 很有用处





## 文章

[**实现并行的copy_if**](https://www.cppstories.com/2021/par-copyif/)

c++17已经实现了一些并行算法，实现比较粗暴

```c++
std::sort(std::execution::par, ...);
std::for_each(std::execution::par, ...);
```

 std::execution::parallel_policy不要求顺序，这样可能有线性的性能提升，但是对于sort，可能需要同步

对于copy_if来说，返回新的对象，这个返回结果，多线程写入，必然需要同步。作者给出了几种实现方案

1 简单加锁 2 利用算法规避锁，3 分块 其中某些场景下多线程并没有起到加速的作用。

第二种方法 用到了[std::exclusive_scan](https://zh.cppreference.com/w/cpp/algorithm/exclusive_scan) 可以了解下，类似haskell map+scanl



[**clang的一个编译告警**-Wsuggest-override](https://quuxplusone.github.io/blog/2021/02/19/virtual-final-silences-override-warning/)

这里讲了一个场景，一个函数同时被virtual和final修饰，可能看不清本身的含义，通过这个编译能让不清楚的接口语义提前暴露出来

并推荐基类 virtual，继承用override/final 尽可能别混用，当然也存在这个基类是另外一个基类的子类的场景，导致同时有virtual和final，尽量避免



[**一个协程的教程**](https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html)



https://www.reddit.com/r/cpp/comments/lp40ag/c20_gcc_trunk_getting_constexpr_usable_caller/

## 视频

[**cpp weekly**](https://www.youtube.com/watch?v=ByKf_foSlXY)

老生常谈，讲的 C++'s Most Vexing Parse 



## 开源项目

[一个用c++实现的lisp](https://github.com/naver/lispe) wiki丰富



[**cpp tips of week** ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/blob/master/214.md) **variadic aggregate initialization**



[**mold** 一个现代的linker](https://lobste.rs/s/t9gvtg/mold_modern_linker) 解决的问题是当前编译环境的瓶颈容易在链接上，没有充分利用并行化优势

mold的目标是要比cat还快，首先并发做文件拷贝，比单线程cat快，其次文件拷贝瓶颈在IO，可以用空闲的cpu做其他事情

llvm 的lld其实在这方面已经做了优化，但作者认为还是慢

还有很多设计可以在readme中看到

讨论 https://lobste.rs/s/t9gvtg/mold_modern_linker



## 工具

toolchain 介绍周边工具https://www.toolchains.net/

hacking cpp 有很多c++的资料，比如https://hackingcpp.com/cpp/std/containers.html



---

看到这里或许你有建议或者疑问或者指出错误，请留言评论! 多谢!  你的评论非常重要！

