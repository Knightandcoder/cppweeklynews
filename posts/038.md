---
layout: post
title:  第38期
---

# C++ 动态新闻推送 第38期

从[reddit](https://www.reddit.com/r/cpp/)/[hackernews](https://news.ycombinator.com/)/[lobsters](https://lobste.rs/)/[meetingcpp](https://www.meetingcpp.com/blog/blogroll/items/Meeting-Cpp-Blogroll-306.html) 摘抄一些c++动态

每周更新

[周刊项目地址](https://github.com/wanghenshui/cppweeklynews)｜[在线地址](https://wanghenshui.github.io/cppweeklynews/) ｜[知乎专栏](https://www.zhihu.com/column/jieyaren) |[腾讯云+社区](https://cloud.tencent.com/developer/column/92884)

欢迎投稿，推荐或自荐文章/软件/资源等，请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)

---

## 资讯

###  编译器信息最新动态推荐关注hellogcc公众号

[OSDT Weekly 2021-11-10 第123期](https://github.com/hellogcc/osdt-weekly/blob/master/weekly/2021-11-10.md)

`TODO fix link then remove this line`

## 文章

- [c++ tip of week ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/)

`TODO fix link then remove this line`

- [Beware of fast-math](https://simonbyrne.github.io/notes/fastmath/#title) 

也说过很多次了，这个-fast-math有很多优化，可能会引入bug

> In [GCC](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html), `-ffast-math` (or `-Ofast`) enables the following options: `-fno-math-errno`, `-funsafe-math-optimizations`, `-ffinite-math-only`, `-fno-rounding-math`, `-fno-signaling-nans`, `-fcx-limited-range` and `-fexcess-precision=fast`. Note that `-funsafe-math-optimizations` is itself a collection of options `-fno-signed-zeros`, `-fno-trapping-math`, `-fassociative-math` and `-freciprocal-math`, plus some extra ones, which we will discuss further below.

比如-fno-math-errno 会引起malloc不报错

比如-fno-signaling-nans会导致isnan函数直接失效

你一定要知道你的场景里会不会有这些判断，不然没有意义

- [A Close Look at a Spinlock](https://blog.regehr.org/archives/2173)

手把手教你看spinlock汇编

- [C++20: Heterogeneous Lookup in (Un)ordered Containers](https://www.cppstories.com/2021/heterogeneous-access-cpp20/)

首先回顾一下Heterogeneous Lookup 的概念

一般来说容器的find/contains只能查相同的类型，就会有这种坑爹的场景

```c++
std::map<std::string, int> m = ...;
absl::string_view some_key = ...;
// Construct a temporary `std::string` to do the query.
// The allocation + copy + deallocation might dominate the find() call.
auto it = m.find(std::string(some_key));
```

白白多了一个复制，如何避免这种浪费呢，引入Heterogeneous Lookup，具体的做法就是定制一个transparent 比较器

```c++
struct StringCmp {
  using is_transparent = void;
  bool operator()(absl::string_view a, absl::string_view b) const {
    return a < b;
  }
};

std::map<std::string, int, StringCmp> m = ...;
absl::string_view some_key = ...;
// The comparator `StringCmp` will accept any type that is implicitly
// convertible to `absl::string_view` and says so by declaring the
// `is_transparent` tag.
// We can pass `some_key` to `find()` without converting it first to
// `std::string`. In this case, that avoids the unnecessary memory allocation
// required to construct the `std::string` instance.
auto it = m.find(some_key);
```



再来看这篇文章的例子 [@Compiler Explorer](https://godbolt.org/z/ed5cvMhfq)

```c++
#include <iostream>
#include <map>
#include <string>
#include <functional>
#include <string_view>
#include <set>

// simple new/delete overloads, so we can check if some memory was allocated...
void* operator new(std::size_t sz){
    std::cout << "Allocating: " << sz << '\n';
    return std::malloc(sz);
}

void operator delete(void* ptr) noexcept{
    std::free(ptr);
}

int main()
{      
    std::map<std::string, int> intMap { { "Hello Super Long String", 1 }, { "Another Longish String", 2 }, {"This cannot fall into SSO buffer", 3 }};
    std::map<std::string, int, std::less<>> trIntMap { { "Hello Super Long String", 1 }, { "Another Longish String", 2 }, {"This cannot fall into SSO buffer", 3 }};
    
    std::cout << "Lookup in intMap with by const char*:\n";
    std::cout << intMap.contains("Hello Super Long String") << '\n';

    /*std::cout << "Lookup in intMap with string_view:\n";
    std::string_view sv("Another Longish String");
    std::cout << intMap.contains(sv) << '\n';*/
    
    std::cout << "Lookup in trIntMap by const char*: \n";
    std::cout << trIntMap.contains("Hello Super Long String") << '\n';
        
    std::cout << "Lookup in trIntMap by string_view: \n";
    std::string_view sv2("Another Longish String");
    std::cout << trIntMap.contains(sv2) << '\n';
}
```



能看到trIntMap没有多余的内存分配，std::less<>和std::less\<std::string>差别这么大？

其实是特化了 transparent比较

```c++
template <>
struct less<void> { 
    using is_transparent = int;

    // simplified version...
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }
};
```

这个带来的性能提升(省拷贝)还是很可观的，但是会引入转换问题，一定要注意

另外就是这个是c++14引入的,（void做模版参数）可能旧的库使用上会有ABI问题

- [c++23状态](https://www.reddit.com/r/cpp/comments/qug17i/c23_near_the_finish_line/)

简单说execution是板上钉钉了。一堆range相关的，network ts没影。（据说两者冲突，总之ASIO又没进）

- [Ray框架介绍](https://www.anyscale.com/blog/modern-distributed-c-with-ray)

一个分布式计算框架

## 视频

- [C++ Weekly ](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw)

`TODO fix link then remove this line`

- [Making Iterators, Views and Containers Easier to Write with Boost.STLInterfaces - Zach Laine CppCon](https://www.youtube.com/watch?v=JByCzWaGxhE&list=PLHTh1InhhwT6DdPY3CPxayypP5DXek_vG&index=9) 介绍 Boost.STLInterfaces的，一个接口类库

## 项目

- [hackingcpp网站更新了profile工具列表](https://hackingcpp.com/cpp/tools/profilers.html)
- [Refureku](https://github.com/jsoysouvanh/Refureku) 一个反射库
- [ces](https://github.com/HappyCerberus/ces) 协程+epoll/socket，玩出花样

---

看到这里或许你有建议或者疑问或者指出错误，请留言评论! 多谢!  你的评论非常重要！也可以帮忙点赞收藏转发！多谢支持！

`TODO fix link then remove this line`

[本文永久链接](https://wanghenshui.github.io/cppweeklynews/posts/038.html)
