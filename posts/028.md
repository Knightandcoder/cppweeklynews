---
layout: post
title:  第28期
---

# C++ 动态新闻推送 第28期

从[reddit](https://www.reddit.com/r/cpp/)/[hackernews](https://news.ycombinator.com/)/[lobsters](https://lobste.rs/)/[meetingcpp](https://www.meetingcpp.com/blog/blogroll/)摘抄一些c++动态。

`TODO fix meetingcpp blogroll link`

每周更新

周刊项目地址 [github](https://github.com/wanghenshui/cppweeklynews)，[在线地址](https://wanghenshui.github.io/cppweeklynews/) | [discord讨论群组](https://discord.gg/cZ9mXVPGx6) ｜[飞书讨论群组](https://applink.feishu.cn/TeeBWN1D)｜[知乎专栏](https://www.zhihu.com/column/jieyaren)

欢迎投稿，推荐或自荐文章/软件/资源等，请[提交 issue](https://github.com/wanghenshui/cppweeklynews/issues)

---

## 资讯

###  编译器信息最新动态推荐关注hellogcc公众号

[本周周报github直达](https://github.com/hellogcc/osdt-weekly/)

`TODO fix link then remove this line`

## 文章

- [c++ tip of week ](https://github.com/QuantlabFinancial/cpp_tip_of_the_week/)

`TODO fix link then remove this line`

- [Turning C++ metaprogramming inside-out with boost::hana](https://thecodepad.com/cpp/turning-c-metaprogramming-inside-out-with-boost-hana/)

介绍boost::hana的使用这里有个[cheatsheet](https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html#tutorial-quickstart-cheatsheet) 元编程，编译器计算，类型和值混起来保存，类似场景，boost::hana是一个好用的现代的库

- [[C++] The Flat Mixin](https://groundswellaudio.github.io/posts/cpp_the_flat_mixin/)

介绍继承模式

作者遇到的场景

```c++
struct heart {

	void pump_blood(){ std::cout << "baboom, baboom\n"; }
	
	bool consume_sugar(){ 
		if (sugar_level < 0)
			return false;
		--sugar_level;
		return true;
	}
	
	int sugar_level = 100;
};

template <class Base>
struct legs : Base {
	void move_legs(){ 
		this->pump_blood();
		std::cout << "legs are moving...\n"; 
	}
};

template <class Base>
struct body : Base {
	
	// hopefully Base has all the methods we need
	void move(float dx, float dy){
		if (not this->consume_sugar())
			return;
		this->move_legs();
		position[0] += dx;
		position[1] += dy;
	}
	
	float position[2] = {0, 0};
};
using final_body = body<legs<heart>>;
```

`using final_body = body<legs<heart>>;`这种是单向的依赖，如何抽出一套组合模版？

这里直接放代码

```c++
include <utility>
#include <type_traits>

template <class... Ts>
struct typelist{};

struct mixin_tag{};

template <class T>
inline constexpr bool is_mixin = std::is_base_of_v<mixin_tag, T>;

template <std::size_t Idx, class Mxn>
struct mixin_base {
	Mxn& root(){ return *static_cast<Mxn*>(this); }
	const Mxn& root() const { return *static_cast<const Mxn*>(this); }
};

template <class Seq, class Mxn, class Core, template <class...> class... Frags>
struct mixin_impl;

template <std::size_t... Idx, class Mxn, class Core, template <class...> class... Frags>
struct mixin_impl<std::integer_sequence<std::size_t, Idx...>, Mxn, Core, Frags...>
	: Core, Frags<mixin_base<Idx, Mxn>>...
{
	using frags_list = typelist<Core, Frags<mixin_base<Idx, Mxn>>...>;
};

template <class Core, template <class...> class... Frags>
struct mixin : 
	mixin_impl
	< 
		std::make_index_sequence<sizeof...(Frags)>, 
		mixin<Core, Frags...>,
		Core,
		Frags...
	>, 
	private mixin_tag
{
};

template <class F>
void invoke_all_one(auto& mxn, auto&& fn){
	if constexpr ( requires  { fn(static_cast<F&>(mxn)); } )
		fn(static_cast<F&>(mxn));
}

template <class... Frags>
void invoke_all_impl(auto&& mxn, auto&& fn, typelist<Frags...>){
	(invoke_all_one<Frags>(mxn, fn), ...);
}

template <class Mxn, class Fn>
	requires is_mixin<std::decay_t<Mxn>>
void invoke_all(Mxn&& mxn, Fn&& fn){
    using list = typename std::decay_t<Mxn>::frags_list;
	invoke_all_impl(mxn, fn, list{});
}

```



以及使用案例

```c++
enum class state {
	happy,
	angry,
	sad, 
	asleep
};

template <state State>
struct tag{};
	
template <class R>
struct brain : R {
	
	template <class Tag>
	void set_state(Tag){
		constexpr auto impl = [] (auto& frag)
			requires requires { frag.change_state(Tag{}); }
			{ frag.change_state(Tag{}); };
		invoke_all(this->root(), impl);
	}
	
	enum state state;
};

template <class R>
struct mouth : R {
	void change_state(tag<state::angry>){
		std::cout << "SKREEEEEEEEEEEEEEEE\n";	
	}
};

template <class R>
struct claws : R {
	void change_state(tag<state::angry>){
		std::cout << "protracting claws...\n";
	}
};

template <class R>
struct tail : R {
	void change_state(tag<state::angry>){
		std::cout << "unfolding tail...\n";
	}
};


struct feet{};

using creature = mixin<feet, tail, claws, mouth, brain>;

int main(){
	creature c;
	c.set_state( tag<state::angry>{} );
}
/*
unfolding tail...
protracting claws...
SKREEEEEEEEEEEEEEEE
*/
```



## 视频

- [C++ Weekly ](https://www.youtube.com/channel/UCxHAlbZQNFU2LgEtiqd2Maw)

`TODO fix link then remove this line`



## 项目



---

看到这里或许你有建议或者疑问或者指出错误，请留言评论! 多谢!  你的评论非常重要！也可以帮忙点赞收藏转发！多谢支持！

[本文永久链接](https://wanghenshui.github.io/cppweeklynews/posts/028.html)
